package com.team4099.robot2025.subsystems.drivetrain.generated

import com.ctre.phoenix6.CANBus
import com.ctre.phoenix6.configs.CANcoderConfiguration
import com.ctre.phoenix6.configs.CurrentLimitsConfigs
import com.ctre.phoenix6.configs.MotorOutputConfigs
import com.ctre.phoenix6.configs.Pigeon2Configuration
import com.ctre.phoenix6.configs.Slot0Configs
import com.ctre.phoenix6.configs.TalonFXConfiguration
import com.ctre.phoenix6.configs.VoltageConfigs
import com.ctre.phoenix6.signals.NeutralModeValue
import com.ctre.phoenix6.signals.StaticFeedforwardSignValue
import com.ctre.phoenix6.swerve.SwerveDrivetrainConstants
import com.ctre.phoenix6.swerve.SwerveModuleConstants
import com.ctre.phoenix6.swerve.SwerveModuleConstants.DriveMotorArrangement
import com.ctre.phoenix6.swerve.SwerveModuleConstants.SteerMotorArrangement
import com.ctre.phoenix6.swerve.SwerveModuleConstantsFactory
import com.team4099.robot2025.config.constants.DrivetrainConstants
import org.team4099.lib.units.base.grams
import org.team4099.lib.units.base.inAmperes
import org.team4099.lib.units.base.inMeters
import org.team4099.lib.units.base.inches
import org.team4099.lib.units.derived.ElectricalPotential
import org.team4099.lib.units.derived.inKilogramsMeterSquared
import org.team4099.lib.units.derived.inRotations
import org.team4099.lib.units.derived.inVolts
import org.team4099.lib.units.derived.inVoltsPerMeters
import org.team4099.lib.units.derived.inVoltsPerMetersPerSecond
import org.team4099.lib.units.derived.inVoltsPerMetersPerSecondPerSecond
import org.team4099.lib.units.derived.inVoltsPerRadian
import org.team4099.lib.units.derived.inVoltsPerRadianPerSecond
import org.team4099.lib.units.derived.inVoltsPerRadianSeconds
import org.team4099.lib.units.derived.inVoltsPerRadiansPerSecond
import org.team4099.lib.units.derived.meterSquared
import org.team4099.lib.units.derived.rotations
import org.team4099.lib.units.derived.volts
import org.team4099.lib.units.inMetersPerSecond
import org.team4099.lib.units.kilo

// Generated by the Tuner X Swerve Project Generator
// https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/tuner-swerve/index.html
object TunerConstants {
  // Both sets of gains need to be tuned to your individual robot.
  // The steer motor uses any SwerveModule.SteerRequestType control request with the
  // output type specified by SwerveModuleConstants.SteerMotorClosedLoopOutput
  private val steerGains: Slot0Configs? =
    Slot0Configs()
      .withKP(
        com.team4099.robot2025.config.constants.DrivetrainConstants.PID
          .STEERING_KP
          .inVoltsPerRadian
      )
      .withKI(
        com.team4099.robot2025.config.constants.DrivetrainConstants.PID
          .STEERING_KI
          .inVoltsPerRadianSeconds
      )
      .withKD(
        com.team4099.robot2025.config.constants.DrivetrainConstants.PID
          .STEERING_KD
          .inVoltsPerRadianPerSecond
      )
      .withKV(
        com.team4099.robot2025.config.constants.DrivetrainConstants.PID
          .STEERING_KV
          .inVoltsPerRadiansPerSecond
      )
      .withStaticFeedforwardSign(StaticFeedforwardSignValue.UseClosedLoopSign)

  // When using closed-loop control, the drive motor uses the control
  // output type specified by SwerveModuleConstants.DriveMotorClosedLoopOutput
  private val driveGains: Slot0Configs? =
    Slot0Configs()
      .withKP(
        com.team4099.robot2025.config.constants.DrivetrainConstants.PID
          .DRIVE_KP
          .inVoltsPerMetersPerSecond
      )
      .withKI(
        com.team4099.robot2025.config.constants.DrivetrainConstants.PID
          .DRIVE_KI
          .inVoltsPerMeters
      )
      .withKD(
        com.team4099.robot2025.config.constants.DrivetrainConstants.PID
          .DRIVE_KD
          .inVoltsPerMetersPerSecondPerSecond
      )
      .withKS(com.team4099.robot2025.config.constants.DrivetrainConstants.PID.DRIVE_KS.inVolts)
      .withKV(
        com.team4099.robot2025.config.constants.DrivetrainConstants.PID
          .DRIVE_KV
          .inVoltsPerMetersPerSecond
      )
      .withKA(
        com.team4099.robot2025.config.constants.DrivetrainConstants.PID
          .DRIVE_KA
          .inVoltsPerMetersPerSecondPerSecond
      )

  // The closed-loop output type to use for the steer motors;
  // This affects the PID/FF gains for the steer motors
  private val kSteerClosedLoopOutput = SwerveModuleConstants.ClosedLoopOutputType.Voltage

  // The closed-loop output type to use for the drive motors;
  // This affects the PID/FF gains for the drive motors
  private val kDriveClosedLoopOutput = SwerveModuleConstants.ClosedLoopOutputType.Voltage

  // The type of motor used for the drive motor
  private val kDriveMotorType = DriveMotorArrangement.TalonFX_Integrated

  // The type of motor used for the drive motor
  private val kSteerMotorType = SteerMotorArrangement.TalonFX_Integrated

  // The remote sensor feedback type to use for the steer motors;
  // When not Pro-licensed, Fused*/Sync* automatically fall back to Remote*
  private val kSteerFeedbackType = SwerveModuleConstants.SteerFeedbackType.FusedCANcoder

  // The stator current at which the wheels start to slip;
  // This needs to be tuned to your individual robot
  private val kSlipCurrent = DrivetrainConstants.DRIVE_STATOR_CURRENT_LIMIT

  // Initial configs for the drive and steer motors and the azimuth encoder; these cannot be null.
  // Some configs will be overwritten; check the `with*InitialConfigs()` API documentation.
  private val driveInitialConfigs =
    TalonFXConfiguration()
      .withCurrentLimits(
        CurrentLimitsConfigs()
          .withStatorCurrentLimit(DrivetrainConstants.DRIVE_STATOR_CURRENT_LIMIT.inAmperes)
          .withStatorCurrentLimitEnable(true)
          .withSupplyCurrentLimit(DrivetrainConstants.DRIVE_SUPPLY_CURRENT_LIMIT.inAmperes)
          .withSupplyCurrentLimitEnable(true)
      )
      .withVoltage(
        VoltageConfigs()
          .withPeakForwardVoltage(DrivetrainConstants.DRIVE_COMPENSATION_VOLTAGE.inVolts)
          .withPeakReverseVoltage(-DrivetrainConstants.DRIVE_COMPENSATION_VOLTAGE.inVolts)
      )

  private val steerInitialConfigs: TalonFXConfiguration =
    TalonFXConfiguration()
      .withCurrentLimits(
        CurrentLimitsConfigs() // Swerve azimuth does not require much torque output, so we
          // can set a relatively low
          // stator current limit to help avoid brownouts without impacting performance.
          .withStatorCurrentLimit(
            DrivetrainConstants.STEERING_STATOR_CURRENT_LIMIT.inAmperes
          )
          .withStatorCurrentLimitEnable(true)
          .withSupplyCurrentLimit(
            DrivetrainConstants.STEERING_SUPPLY_CURRENT_LIMIT.inAmperes
          )
          .withSupplyCurrentLimitEnable(true)
      )
      // setting brake might be unneccessary but whatever
      .withMotorOutput(MotorOutputConfigs().withNeutralMode(NeutralModeValue.Brake))
      .withVoltage(
        VoltageConfigs()
          .withPeakForwardVoltage(DrivetrainConstants.STEERING_COMPENSATION_VOLTAGE.inVolts)
          .withPeakReverseVoltage(
            -DrivetrainConstants.STEERING_COMPENSATION_VOLTAGE.inVolts
          )
      )

  private val encoderInitialConfigs = CANcoderConfiguration()

  // Configs for the Pigeon 2; leave this null to skip applying Pigeon 2 configs
  private val pigeonConfigs: Pigeon2Configuration? = null

  // CAN bus that the devices are located on;
  // All swerve devices must share the same CAN bus
  val kCANBus: CANBus = CANBus("", "./logs/example.hoot")

  // Theoretical free speed (m/s) at 12 V applied output;
  // This needs to be tuned to your individual robot
  val kSpeedAt12Volts = DrivetrainConstants.DRIVE_SETPOINT_MAX

  // Every 1 rotation of the azimuth results in kCoupleRatio drive motor turns;
  // This may need to be tuned to your individual robot
  private const val kCoupleRatio = 3.5714285714285716

  private const val kDriveGearRatio = 6.746031746031747
  private const val kSteerGearRatio = 21.428571428571427
  private val kWheelRadius = DrivetrainConstants.WHEEL_DIAMETER / 2

  private const val kInvertLeftSide = false
  private const val kInvertRightSide = true

  private const val kPigeonId = 1

  // These are only used for simulation
  private val kSteerInertia = 0.04.kilo.grams.meterSquared
  private val kDriveInertia = 0.025.kilo.grams.meterSquared

  // Simulated voltage necessary to overcome friction
  private val kSteerFrictionVoltage: ElectricalPotential = 0.2.volts
  private val kDriveFrictionVoltage: ElectricalPotential = 0.2.volts

  val CTREDrivetrainConstants: SwerveDrivetrainConstants =
    SwerveDrivetrainConstants()
      .withCANBusName(kCANBus.name)
      .withPigeon2Id(kPigeonId)
      .withPigeon2Configs(pigeonConfigs)

  private val ConstantCreator:
    SwerveModuleConstantsFactory<
      TalonFXConfiguration, TalonFXConfiguration, CANcoderConfiguration> =
      SwerveModuleConstantsFactory<
        TalonFXConfiguration, TalonFXConfiguration, CANcoderConfiguration>()
        .withDriveMotorGearRatio(kDriveGearRatio)
        .withSteerMotorGearRatio(kSteerGearRatio)
        .withCouplingGearRatio(kCoupleRatio)
        .withWheelRadius(kWheelRadius.inMeters)
        .withSteerMotorGains(steerGains)
        .withDriveMotorGains(driveGains)
        .withSteerMotorClosedLoopOutput(kSteerClosedLoopOutput)
        .withDriveMotorClosedLoopOutput(kDriveClosedLoopOutput)
        .withSlipCurrent(kSlipCurrent.inAmperes)
        .withSpeedAt12Volts(kSpeedAt12Volts.inMetersPerSecond)
        .withDriveMotorType(kDriveMotorType)
        .withSteerMotorType(kSteerMotorType)
        .withFeedbackSource(kSteerFeedbackType)
        .withDriveMotorInitialConfigs(driveInitialConfigs)
        .withSteerMotorInitialConfigs(steerInitialConfigs)
        .withEncoderInitialConfigs(encoderInitialConfigs)
        .withSteerInertia(kSteerInertia.inKilogramsMeterSquared)
        .withDriveInertia(kDriveInertia.inKilogramsMeterSquared)
        .withSteerFrictionVoltage(kSteerFrictionVoltage.inVolts)
        .withDriveFrictionVoltage(kDriveFrictionVoltage.inVolts)

  // Front Left
  private const val kFrontLeftDriveMotorId = 11
  private const val kFrontLeftSteerMotorId = 21
  private const val kFrontLeftEncoderId = 31
  private val kFrontLeftEncoderOffset = 0.419189453125.rotations
  private const val kFrontLeftSteerMotorInverted = true
  private const val kFrontLeftEncoderInverted = false

  private val kFrontLeftXPos = 11.375.inches
  private val kFrontLeftYPos = 11.375.inches

  // Front Right
  private const val kFrontRightDriveMotorId = 12
  private const val kFrontRightSteerMotorId = 22
  private const val kFrontRightEncoderId = 32
  private val kFrontRightEncoderOffset = -0.349853515625.rotations
  private const val kFrontRightSteerMotorInverted = true
  private const val kFrontRightEncoderInverted = false

  private val kFrontRightXPos = 11.375.inches
  private val kFrontRightYPos = -11.375.inches

  // Back Left
  private const val kBackLeftDriveMotorId = 13
  private const val kBackLeftSteerMotorId = 23
  private const val kBackLeftEncoderId = 33
  private val kBackLeftEncoderOffset = 0.0126953125.rotations
  private const val kBackLeftSteerMotorInverted = true
  private const val kBackLeftEncoderInverted = false

  private val kBackLeftXPos = -11.375.inches
  private val kBackLeftYPos = 11.375.inches

  // Back Right
  private const val kBackRightDriveMotorId = 14
  private const val kBackRightSteerMotorId = 24
  private const val kBackRightEncoderId = 34
  private val kBackRightEncoderOffset = -0.3984375.rotations
  private const val kBackRightSteerMotorInverted = true
  private const val kBackRightEncoderInverted = false

  private val kBackRightXPos = -11.375.inches
  private val kBackRightYPos = -11.375.inches

  val FrontLeft:
    SwerveModuleConstants<TalonFXConfiguration?, TalonFXConfiguration?, CANcoderConfiguration?> =
      ConstantCreator.createModuleConstants(
        kFrontLeftSteerMotorId,
        kFrontLeftDriveMotorId,
        kFrontLeftEncoderId,
        kFrontLeftEncoderOffset.inRotations,
        kFrontLeftXPos.inMeters,
        kFrontLeftYPos.inMeters,
        kInvertLeftSide,
        kFrontLeftSteerMotorInverted,
        kFrontLeftEncoderInverted
      )
  val FrontRight:
    SwerveModuleConstants<TalonFXConfiguration?, TalonFXConfiguration?, CANcoderConfiguration?> =
      ConstantCreator.createModuleConstants(
        kFrontRightSteerMotorId,
        kFrontRightDriveMotorId,
        kFrontRightEncoderId,
        kFrontRightEncoderOffset.inRotations,
        kFrontRightXPos.inMeters,
        kFrontRightYPos.inMeters,
        kInvertRightSide,
        kFrontRightSteerMotorInverted,
        kFrontRightEncoderInverted
      )
  val BackLeft:
    SwerveModuleConstants<TalonFXConfiguration?, TalonFXConfiguration?, CANcoderConfiguration?> =
      ConstantCreator.createModuleConstants(
        kBackLeftSteerMotorId,
        kBackLeftDriveMotorId,
        kBackLeftEncoderId,
        kBackLeftEncoderOffset.inRotations,
        kBackLeftXPos.inMeters,
        kBackLeftYPos.inMeters,
        kInvertLeftSide,
        kBackLeftSteerMotorInverted,
        kBackLeftEncoderInverted
      )
  val BackRight:
    SwerveModuleConstants<TalonFXConfiguration?, TalonFXConfiguration?, CANcoderConfiguration?> =
      ConstantCreator.createModuleConstants(
        kBackRightSteerMotorId,
        kBackRightDriveMotorId,
        kBackRightEncoderId,
        kBackRightEncoderOffset.inRotations,
        kBackRightXPos.inMeters,
        kBackRightYPos.inMeters,
        kInvertRightSide,
        kBackRightSteerMotorInverted,
        kBackRightEncoderInverted
      )
}
